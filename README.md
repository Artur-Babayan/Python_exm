# Python_exm
1. exam.py
1.1 import json:
  Мы импортируем модуль json, который позволит нам работать с JSON-файлами.
1.2 class Exam::
  Мы определяем класс Exam, который будет представлять экзамен.

1.3 def __init__(self, exam_file, result_file):
  Это конструктор класса Exam, который принимает два аргумента: exam_file (файл с вопросами экзамена) и result_file (файл, в который будут сохранены результаты).

1.4 self.exam_file = exam_file и self.result_file = result_file:
   Мы сохраняем переданные аргументы как атрибуты объекта класса, чтобы они были доступны в других методах.
   
1.5 def load_my_exam_data(self):
   Этот метод загружает данные экзамена из файла JSON (exam_file) и сохраняет их в атрибуте self.exam_data.
   
1.6 with open(self.exam_file, 'r', encoding='utf-8') as json_file:
   Мы открываем файл JSON для чтения.

1.7 self.exam_data = json.load(json_file): 
  Мы загружаем данные из файла JSON в атрибут self.exam_data с помощью функции json.load().
  
1.8 def take_my_exam(self):
  Этот метод выполняет экзамен, предлагая студенту ввести свое имя и фамилию, а затем предоставляет вопросы и записывает ответы студента.
  
1.9 student_name = input("Please input your name: ") и student_surname = input("Please input your surname: "): 
  Мы запрашиваем у студента имя и фамилию с помощью функции input() и сохраняем их в переменных student_name и student_surname.
  
1.10 user_answers = {}: 
  Мы создаем пустой словарь user_answers, который будет содержать ответы студента на вопросы экзамена.
  
1.11 for question_number, question_data in self.exam_data['exam_content'].items():
  Мы перебираем вопросы из атрибута exam_content в self.exam_data. question_number содержит номер вопроса, а question_data содержит данные о вопросе.
  Внутри этого цикла мы предоставляем студенту текст вопроса и варианты ответов, а затем запрашиваем ответ студента.
  
1.12 user_answer = input("Enter the letter of your answer (A/B/C/D): ").strip().lower(): 
  Мы запрашиваем ответ студента и преобразуем его в нижний регистр.
  Если введенный ответ не соответствует вариантам A, B, C или D, мы выводим сообщение об ошибке и продолжаем цикл.
  Мы записываем ответ студента в словарь user_answers, связывая его с номером вопроса.
  После ответа на все вопросы, мы создаем словарь result, который содержит имя студента, фамилию и ответы на вопросы.
  
1.14 Мы сохраняем результаты в файл JSON с помощью json.dump().

1.15 В блоке if __name__ == "__main__": 
  создается объект класса Exam, загружаются данные экзамена и выполняется экзамен


2. maxSubArray.py (алгоритм Кадана)
   
2.1 from typing import List:
   Мы импортируем класс List из модуля typing, чтобы указать тип аргумента nums как список целых чисел.
   
2.2 class Solution:
    Мы определяем класс Solution, который будет содержать метод maxSubArray для решения задачи нахождения максимальной суммы подмассива.
   
2.3 def maxSubArray(self, nums: List[int]) -> int:
    Мы определяем метод maxSubArray, который принимает список целых чисел nums и возвращает целое число (максимальную сумму подмассива).

2.4 max_sum = nums[0]:
    Мы инициализируем переменную max_sum значением первого элемента из списка nums. Эта переменная будет хранить максимальную сумму подмассива на текущем этапе обработки.

2.5 current_sum = nums[0]: 
    Мы инициализируем переменную current_sum значением первого элемента из списка nums. Эта переменная будет хранить текущую сумму подмассива на текущем этапе обработки.

2.6 for i in range(1, len(nums)):
    Мы начинаем цикл for, который перебирает элементы списка nums начиная с индекса 1 (второго элемента).

2.7 current_sum = max(nums[i], current_sum + nums[i]): 
    Мы обновляем current_sum, выбирая максимальное значение между текущим элементом nums[i] и суммой текущего элемента с current_sum.
    Это позволяет нам решить, следует ли продолжать текущий подмассив или начать новый подмассив с nums[i].

2.8 max_sum = max(max_sum, current_sum):
    Мы обновляем max_sum, выбирая максимальное значение между текущей максимальной суммой max_sum и текущей суммой подмассива current_sum. 
    Это позволяет нам найти максимальную сумму подмассива на текущем этапе.

2.9 return max_sum: 
    После завершения цикла, мы возвращаем значение max_sum, которое содержит максимальную сумму подмассива в списке nums.



3.  fourSum.py
3.1 from typing import List:
   Мы импортируем класс List из модуля typing, чтобы указать тип аргумента nums как список целых чисел, и тип возвращаемого значения как список списков целых чисел.

3.2 class Solution:
     Мы определяем класс Solution, который будет содержать метод fourSum для решения задачи нахождения уникальных четверок чисел с заданной суммой.
    
3.3 def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
    Мы определяем метод fourSum, который принимает список целых чисел nums и целое число target, а возвращает список списков целых чисел (уникальные четверки чисел с суммой, равной target).

3.4 nums.sort():
    Мы сортируем список nums в порядке возрастания. Это позволяет нам упростить поиск комбинаций чисел с заданной суммой, так как числа будут упорядочены.

3.5 result = []:
    Мы инициализируем пустой список result, который будет содержать уникальные четверки чисел с заданной суммой.

3.6 for i in range(len(nums) - 3):
    Мы начинаем первый цикл for, который будет перебирать индексы i от 0 до len(nums) - 3. Ограничение len(nums) - 3 используется, чтобы убедиться, что остались как минимум три элемента для выбора для оставшихся трех чисел.

3.7 if i > 0 and nums[i] == nums[i - 1]: continue:
    Мы проверяем, является ли текущий элемент nums[i] дубликатом предыдущего элемента. Если это так, мы используем continue, чтобы пропустить текущую итерацию и избежать дубликатов.

3.8 for j in range(i + 1, len(nums) - 2):
    Мы начинаем второй цикл for, который будет перебирать индексы j от i + 1 до len(nums) - 2. Ограничение len(nums) - 2 используется, чтобы убедиться, 
    что остались как минимум два элемента для выбора для оставшихся двух чисел. Этот цикл начинается сразу после i, чтобы избежать дубликатов.

3.9 if j > i + 1 and nums[j] == nums[j - 1]: continue: 
    Мы проверяем, является ли текущий элемент nums[j] дубликатом предыдущего элемента. Если это так, мы используем continue, чтобы пропустить текущую итерацию и избежать дубликатов.

3.10 left, right = j + 1, len(nums) - 1:
    Мы инициализируем два указателя left и right, которые будут использоваться для движения внутри списка nums при поиске четверок чисел с заданной суммой.

3.11 while left < right:
    Мы начинаем цикл while, который будет выполняться, пока left меньше чем right. Этот цикл будет использоваться для поиска комбинаций чисел с заданной суммой.

3.12 current_sum = nums[i] + nums[j] + nums[left] + nums[right]:
    Мы вычисляем текущую сумму четырех чисел, соответствующих текущим индексам.

3.13 Если current_sum равна target, мы добавляем эту комбинацию чисел в список result. 
      Затем мы обрабатываем дубликаты, если такие имеются, с помощью двух циклов while. Один из них перемещает left, а другой - right, чтобы избежать повторного использования тех же чисел.

Если current_sum меньше target, мы увеличиваем left на 1, чтобы увеличить сумму.

Если current_sum больше target, мы уменьшаем right на 1, чтобы уменьшить сумму.

После завершения циклов, метод возвращает список result, который содержит все уникальные четверки чисел с суммой, равной target.

4. palindromePairs.py
4.1 def is_palindrome(word):
    Мы определяем внутреннюю функцию is_palindrome, которая принимает строку word и возвращает True, если строка является палиндромом, и False в противном случае.

4.2 word_index = {word: i for i, word in enumerate(words)}: 
    Мы создаем словарь word_index, в котором ключами являются строки из списка words, а значениями - их индексы в списке. Этот словарь будет использоваться для быстрого поиска индексов строк в списке words.

4.3 result = []:
    Мы инициализируем пустой список result, который будет содержать индексы строк, образующих палиндромные пары.

4.4 for i, word in enumerate(words):
    Мы начинаем первый цикл for, который перебирает индексы i и строки word из списка words.

4.5 for j in range(len(word) + 1):
    Мы начинаем второй цикл for, который перебирает все возможные индексы j внутри строки word, включая 0 и len(word).

4.6 left_part = word[:j] и right_part = word[j:]:
    Мы разделяем текущую строку word на две части: левую left_part, состоящую из символов от начала строки до индекса j, и правую right_part, состоящую из символов с индекса j и до конца строки.

4.7 if j > 0 and is_palindrome(left_part) and right_part[::-1] in word_index:
    Мы проверяем условие, что индекс j больше 0 (чтобы избежать пустых строк), и что left_part является палиндромом (is_palindrome(left_part)) и right_part[::-1] (обратная версия right_part) содержится в словаре word_index. 
    Если это условие выполняется, то мы добавляем пару [word_index[right_part[::-1]], i] в список result.
    Это означает, что правая часть right_part палиндрома образует палиндромную пару с строкой, находящейся в словаре под ключом right_part[::-1].

4.8 if is_palindrome(right_part) and left_part[::-1] in word_index and i != word_index[left_part[::-1]]:
    Мы проверяем условие, что right_part является палиндромом (is_palindrome(right_part)), что обратная версия left_part (left_part[::-1]) содержится в словаре word_index и что индекс i не равен индексу, связанному с обратной версией left_part.       Если это условие выполняется, то мы добавляем пару [i, word_index[left_part[::-1]]] в список result. Это означает, что левая часть left_part палиндрома образует палиндромную пару с строкой, находящейся в словаре под ключом left_part[::-1].

4.9 После завершения всех циклов, метод возвращает список result, который содержит индексы строк, образующих палиндромные пары.
