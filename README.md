# Python_exm
1. exam.py
1.1 import json:
  Мы импортируем модуль json, который позволит нам работать с JSON-файлами.
1.2 class Exam::
  Мы определяем класс Exam, который будет представлять экзамен.

1.3 def __init__(self, exam_file, result_file):
  Это конструктор класса Exam, который принимает два аргумента: exam_file (файл с вопросами экзамена) и result_file (файл, в который будут сохранены результаты).

1.4 self.exam_file = exam_file и self.result_file = result_file:
   Мы сохраняем переданные аргументы как атрибуты объекта класса, чтобы они были доступны в других методах.
   
1.5 def load_my_exam_data(self):
   Этот метод загружает данные экзамена из файла JSON (exam_file) и сохраняет их в атрибуте self.exam_data.
   
1.6 with open(self.exam_file, 'r', encoding='utf-8') as json_file:
   Мы открываем файл JSON для чтения.

1.7 self.exam_data = json.load(json_file): 
  Мы загружаем данные из файла JSON в атрибут self.exam_data с помощью функции json.load().
  
1.8 def take_my_exam(self):
  Этот метод выполняет экзамен, предлагая студенту ввести свое имя и фамилию, а затем предоставляет вопросы и записывает ответы студента.
  
1.9 student_name = input("Please input your name: ") и student_surname = input("Please input your surname: "): 
  Мы запрашиваем у студента имя и фамилию с помощью функции input() и сохраняем их в переменных student_name и student_surname.
  
1.10 user_answers = {}: 
  Мы создаем пустой словарь user_answers, который будет содержать ответы студента на вопросы экзамена.
  
1.11 for question_number, question_data in self.exam_data['exam_content'].items():
  Мы перебираем вопросы из атрибута exam_content в self.exam_data. question_number содержит номер вопроса, а question_data содержит данные о вопросе.
  Внутри этого цикла мы предоставляем студенту текст вопроса и варианты ответов, а затем запрашиваем ответ студента.
  
1.12 user_answer = input("Enter the letter of your answer (A/B/C/D): ").strip().lower(): 
  Мы запрашиваем ответ студента и преобразуем его в нижний регистр.
  Если введенный ответ не соответствует вариантам A, B, C или D, мы выводим сообщение об ошибке и продолжаем цикл.
  Мы записываем ответ студента в словарь user_answers, связывая его с номером вопроса.
  После ответа на все вопросы, мы создаем словарь result, который содержит имя студента, фамилию и ответы на вопросы.
  
1.14 Мы сохраняем результаты в файл JSON с помощью json.dump().

1.15 В блоке if __name__ == "__main__": 
  создается объект класса Exam, загружаются данные экзамена и выполняется экзамен


2. maxSubArray.py (алгоритм Кадана)
   
2.1 from typing import List:
   Мы импортируем класс List из модуля typing, чтобы указать тип аргумента nums как список целых чисел.
   
2.2 class Solution:
    Мы определяем класс Solution, который будет содержать метод maxSubArray для решения задачи нахождения максимальной суммы подмассива.
   
2.3 def maxSubArray(self, nums: List[int]) -> int:
    Мы определяем метод maxSubArray, который принимает список целых чисел nums и возвращает целое число (максимальную сумму подмассива).

2.4 max_sum = nums[0]:
    Мы инициализируем переменную max_sum значением первого элемента из списка nums. Эта переменная будет хранить максимальную сумму подмассива на текущем этапе обработки.

2.5 current_sum = nums[0]: 
    Мы инициализируем переменную current_sum значением первого элемента из списка nums. Эта переменная будет хранить текущую сумму подмассива на текущем этапе обработки.

2.6 for i in range(1, len(nums)):
    Мы начинаем цикл for, который перебирает элементы списка nums начиная с индекса 1 (второго элемента).

2.7 current_sum = max(nums[i], current_sum + nums[i]): 
    Мы обновляем current_sum, выбирая максимальное значение между текущим элементом nums[i] и суммой текущего элемента с current_sum.
    Это позволяет нам решить, следует ли продолжать текущий подмассив или начать новый подмассив с nums[i].

2.8 max_sum = max(max_sum, current_sum):
    Мы обновляем max_sum, выбирая максимальное значение между текущей максимальной суммой max_sum и текущей суммой подмассива current_sum. 
    Это позволяет нам найти максимальную сумму подмассива на текущем этапе.

2.9 return max_sum: 
    После завершения цикла, мы возвращаем значение max_sum, которое содержит максимальную сумму подмассива в списке nums.
    
